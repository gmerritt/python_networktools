__author__ = 'leahanderson'

'''
    these functions are used to read in and manipulate/analyze NGSIM trajectory data
    The idea is to FIRST FILTER into the subset of trajectories you are interested in, and then convert into a
    human-readable trajectory object type -- because the whole trajectory files are huge, and the conversion process is
    relatively slow... so first run read_trajectory_file, then do filtering, then convert the resulting list of data
    points into Trajectory objects!
'''



def read_trajectory_file(trajectoryfile, id_prefix=""):
    #THIS READS IN THE TRAJECTORY FILES. IT IS THE FIRST THING YOU NEED TO DO.
    trajlist=[]
    with open(trajectoryfile) as inputfile:
        for line in inputfile:
            lo = line.split()
            lo[0] = lo[0]+id_prefix
            trajlist.append(lo)
    return trajlist



'''
    the following operations are intended to run on lists generated by read_trajectory.
    they typically return subsets of a trajectory list, actually as a list of list to be
    consistent with the output of the read_trajectory_data function.
'''

def filter_by_link(tlist, link, intersection=0):
    #you can filter by intersection by setting link = 0 and setting intersection value
    link_trajs=[]
    for tl in tlist:
        for dp in tl:
                if dp[16] == intersection and dp[17] == link:
                    link_trajs.append(dp)
    return [link_trajs]


def filter_by_origin(tlist, origin):
    origin_trajs=[]
    for tl in tlist:
        for dp in tl:
            if dp[14] == str(origin):
                origin_trajs.append(dp)
    return [origin_trajs]


def filter_by_destination(tlist, destination):
    dest_trajs=[]
    for tl in tlist:
        for dp in tl:
                if dp[14] == str(destination):
                    dest_trajs.append(dp)
    return [dest_trajs]



'''
    once you have culled down the total list of trajectories into one that is more managable, use these functions to
    transform this list into Trajectory objects and manipulate these objects
'''
from ngsimobjects import Trajectory
from numpy import histogram, linspace

def direct_to_trajectories(dataset):
    from os import listdir, path
    tlist=[]
    idprefixes=['a','b','c','d','e','f','g']
    fn=-0
    for f in listdir(dataset+'/vehicle-trajectory-data/'):
        if path.isdir(dataset+'/vehicle-trajectory-data/'+f):
            filename = listdir(dataset+'/vehicle-trajectory-data/'+f)[0]
            idp = idprefixes[fn]
            print filename, idp
            fn+=1
            tlist.append(read_trajectory_file(dataset+'/vehicle-trajectory-data/'+f+'/'+filename, idp))
    trajectories = convert_list_to_trajectories(tlist)
    return trajectories


def convert_list_to_trajectories(tlist):
    vehs={}
    for tl in tlist:
        for dp in tl:
            # print(dp)
            # time.sleep(1)
            # print(dp[0])
            id = dp[0]
            if not vehs.has_key(id):
                vehs[id]=[]
            vehs[id].append(dp)
    # print vehs[id]
    trajectories = []
    for v in vehs.keys():
        trajectories.append(Trajectory(vehs[v]))
    return trajectories

def output_loop_events(trajectories, link_number, direction):
    exit_events={}
    for t in trajectories:
        time_in_link, lane_in_link = t.find_last_time_in_link(link_number, direction)
        if lane_in_link not in exit_events.keys():
            exit_events[lane_in_link] = []
        if lane_in_link is not None:
            exit_events[lane_in_link].append(time_in_link)
            print t.id, lane_in_link
    return exit_events


def output_count_sensor(trajectories, link_number, direction, time_range, resolution, lanes=0):
    exit_events = output_loop_events(trajectories, link_number, direction)
    print 'compiled exit events'
    if lanes==0:
        lanes=exit_events.keys()
    elif not isinstance(lanes,list):
        lanes=[lanes]
    event_times = []
    for lane in lanes:
        event_times = event_times+exit_events[lane]
    time_bounds = linspace(time_range[0],time_range[1], resolution*1000).tolist()
    # print time_bounds
    counts_array, time_array = histogram(event_times, bins=time_bounds)
    return counts_array.tolist(), time_array.tolist()[1::]


def link_outflow_events_by_intersection(trajectories, intersection):
    link_outflows = {}
    missing_count = 0
    for t in trajectories:
        if intersection in t.intersection:
            entry_index = t.intersection.index(intersection)
            movement = t.movement[entry_index]
            if entry_index<10:
                incoming_link=t.origin
                indirection = ''
                etime = t.time[entry_index]
            else:
                incoming_link = t.link[entry_index-1]
                indirection = t.direction[entry_index-1]
                etime = t.time[entry_index-1]
                if incoming_link==0:
                    link_history  = t.link[0:entry_index]
                    if sum(link_history)==0:
                        incoming_link = t.origin
                        indirection = ''
                    else:
                        link_history = [h for h in link_history if h!=0]
                        candidate = link_history[-1]
                        if candidate == intersection:
                            incoming_link = candidate
                            indirection = 'NB'
                        elif candidate == intersection+1:
                            incoming_link = candidate
                            indirection = 'SB'
                        else:
                            missing_count +=1
                        # elif candidate == intersection+2:
                        #     incoming_link = intersection+1
                        #     indirection = 'SB'
                        # elif candidate == intersection-1:
                        #     incoming_link = intersection
                        #     indirection = 'NB'
            if incoming_link!=0:
                inlink = str(incoming_link)+indirection
                if inlink == '1NB': inlink = '101'
                if inlink == '5SB': inlink = '108'
                if not inlink in link_outflows.keys():
                    link_outflows[inlink] = {movement: [etime]}
                elif not movement in link_outflows[inlink].keys():
                    link_outflows[inlink][movement] = [etime]
                else:
                    link_outflows[inlink][movement]. append(etime)
    print 'intersection '+str(intersection)+' complete, '+str(missing_count)+' link exits were not counted'
    return link_outflows


def network_outflow_events(trajectories):
    exit_dict = {}
    for t in trajectories:
        exit_point = t.get_destination_time()
        if not exit_point[0] in exit_dict.keys():
            exit_dict[exit_point[0]] = [exit_point[1]]
        else:
            exit_dict[exit_point[0]].append(exit_point[1])
    return exit_dict


def network_inflow_events(trajectories):
    entry_dict={}
    for t in trajectories:
        entry_point = t.get_origin_time()
        if not entry_point[0] in entry_dict.keys():
            entry_dict[entry_point[0]] = {entry_point[1]:[entry_point[2]]}
        elif not entry_point[1] in entry_dict[entry_point[0]].keys():
            entry_dict[entry_point[0]][entry_point[1]]=[entry_point[2]]
        else:
            entry_dict[entry_point[0]][entry_point[1]].append(entry_point[2])
    return entry_dict
