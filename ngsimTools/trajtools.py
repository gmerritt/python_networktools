__author__ = 'leahanderson'

'''
    these functions are used to read in and manipulate/analyze NGSIM trajectory data
    The idea is to FIRST FILTER into the subset of trajectories you are interested in, and then convert into a
    human-readable trajectory object type -- because the whole trajectory files are huge, and the conversion process is
    relatively slow... so first run read_trajectory_file, then do filtering, then convert the resulting list of data
    points into Trajectory objects!
'''



def read_trajectory_file(trajectoryfile):
    #THIS READS IN THE TRAJECTORY FILES. IT IS THE FIRST THING YOU NEED TO DO.
    trajlist=[]
    with open(trajectoryfile) as inputfile:
        for line in inputfile:
            trajlist.append(line.split())
    return trajlist



'''
    the following operations are intended to run on lists generated by read_trajectory.
    they typically return subsets of a trajectory list, actually as a list of list to be
    consistent with the output of the read_trajectory_data function.
'''

def filter_by_link(tlist, link, intersection=0):
    #you can filter by intersection by setting link = 0 and setting intersection value
    link_trajs=[]
    for tl in tlist:
        for dp in tl:
                if dp[16] == intersection and dp[17] == link:
                    link_trajs.append(dp)
    return [link_trajs]


def filter_by_origin(tlist, origin):
    origin_trajs=[]
    for tl in tlist:
        for dp in tl:
            if dp[14] == str(origin):
                origin_trajs.append(dp)
    return [origin_trajs]


def filter_by_destination(tlist, destination):
    dest_trajs=[]
    for tl in tlist:
        for dp in tl:
                if dp[14] == str(destination):
                    dest_trajs.append(dp)
    return [dest_trajs]



'''
    once you have culled down the total list of trajectories into one that is more managable, use these functions to
    transform this list into Trajectory objects and manipulate these objects
'''
from ngsimobjects import Trajectory
from numpy import histogram, linspace


def convert_list_to_trajectories(tlist):
    vehs={}
    for tl in tlist:
        for dp in tl:
            # print(dp)
            # time.sleep(1)
            # print(dp[0])
            id = int(dp[0])
            if not vehs.has_key(id):
                vehs[id]=[]
            vehs[id].append(dp)
    # print vehs[id]
    trajectories = []
    for v in vehs.keys():
        trajectories.append(Trajectory(vehs[v]))
    return trajectories

def output_loop_events(trajectories, link_number, direction):
    exit_events={}
    for t in trajectories:
        time_in_link, lane_in_link = t.find_last_time_in_link(link_number, direction)
        if lane_in_link not in exit_events.keys():
            exit_events[lane_in_link] = []
        if lane_in_link is not None:
            exit_events[lane_in_link].append(time_in_link)
            print t.id, lane_in_link
    return exit_events


def output_count_sensor(trajectories, link_number, direction, time_range, resolution, lanes=0):
    exit_events = output_loop_events(trajectories, link_number, direction)
    print 'compiled exit events'
    if lanes==0:
        lanes=exit_events.keys()
    elif not isinstance(lanes,list):
        lanes=[lanes]
    event_times = []
    for lane in lanes:
        event_times = event_times+exit_events[lane]
        print lane
    time_bounds = linspace(time_range[0],time_range[1], resolution*1000).tolist()
    # print time_bounds
    counts_array, time_array = histogram(event_times, bins=time_bounds)
    return counts_array.tolist(), time_array.tolist()[1::]


